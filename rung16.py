import os,numpy
from parameters import *

def inp4td(X0,step=1,nroots=5,increase=False):
    global job_name,system_name,nproc,memory,qm_charge,qm_mult,uks,qm_template
    global atm
    xyz=numpy.matrix.tolist(X0)[0]

    print('Running TD-DFT single point to decide the target state.')
    # Generate a TD-DFT single point task to decide iroot.
    filename=f'{system_name}_step{step}_TD'
    with open(f'{filename}.gjf','w') as gen:
        gen.write('! Gaussian16 input file generated by XMECP\n')
        gen.write(f'%nprocshared={nproc}\n')
        gen.write(f'%mem={memory}GB\n')
        if increase:
            gen.write(f'%oldchk={scratch_path}/{system_name}_step{step}_TD.chk')
        elif step==1:
            gen.write(f'%oldchk={scratch_path}/{system_name}_ref_stable.chk')
        elif step>1:
            gen.write(f'%oldchk={scratch_path}/{system_name}_step{step-1}_TD.chk')
        gen.write(f'%chk={filename}.chk\n')
        gen.write('#p NoSymm ')
        if step>1:
            gen.write('Guess=Read ')
        gen.write(f'TD=(')
        if increase or step>1:
            gen.write('Read,')
        if qm_mult==1 and (state1_mult==3 or state2_mult==3):
            gen.write('Triplets,')
        gen.write(f'NStates={nroots})\n')
        with open(qm_template,'r') as read:
            for line in read.readlines():
                l=line.split()
                if len(l)!=0:
                    gen.write(line.strip('\n'))
        gen.write(f'\n\nTD-DFT Single Point Task\n\n{qm_charge} {qm_mult}\n')
        for i in range(len(atm)):
            gen.write(f'{atm[i]}'.ljust(4))
            for j in range(3):
                gen.write(f'{xyz[j+3*i]:8f}'.rjust(16))
            gen.write('\n')
        gen.write('\n')
        with open(qm_template,'r') as read:
            flag=False
            for line in extrakeys.readlines():
                l=line.split()
                if flag==False and len(l)==0:
                    flag=True
                    continue
                if flag:
                    gen.write(line)
        gen.write('\n\n')

    # Now run TD-DFT single point task.
    with os.popen(f'g16 < {filename}.gjf > {filename}.log') as run:
        null=run.read()
    
    # Read TD-DFT results.
    s2val=[]
    with open(f'{filename}.log') as read:
        for line in read.readlines():
            s2val=0.
            if 'Excitation energies and oscillator strengths:' in line:
                flag=True
                continue
            if flag:
                l=line.split()
                if '<S**2>' in line:
                    s2val.append(float(line[-1].lstrip('<S**2>=')))
                    continue
            if len(s2val)==nroots:
                break

    # Search for target states.
    ijroots=[]
    global mecp_wordlist
    for i in range(2):
        flag=False
        if (qm_mult!=1 and (if_td1 or\
            (mecp_wordlist[0+i]==qm_mult and mecp_wordlist[2+i]!=0)   or\
            (mecp_wordlist[0+i]!=qm_mult and mecp_wordlist[2+i]>=2))) or\
           (qm_mult==1 and (mecp_wordlist[0+i]!=qm_mult and (if_td1 or mecp_wordlist[2+i]>=2))):
            # Eigenvalue for spin-square operator of pure spin state.
            s=(mecp_wordlist[0+i]-1)/2
            s2=s*(s+1)
            for j in range(len(s2val)):
                if s2-0.8 <= s2val[j] <= s2+1.2:
                    ijroots.append(1+j)
                    flag=True
                    print(f'Found target state {1+i} as TD-DFT excited state {1+j}.')
                    print(f'Expected value for spin-square operator is: {s2val[j]:3f}')
                    break
        else:
            ijroots.append(0)
            flag=True
            print(f'Target state {1+i} is not a TD-DFT excited state.')
        if flag==False:
            print(f'Target state {1+i} was not found in current CIS space composed of {len(s2val)} states.')
            # Backup .log and .chk files.
            os.system(f'rm {filename}.gjf')
            os.system(f'mv {filename}.log {scratch_path}/{filename}.log')
            os.system(f'mv {filename}.chk {scratch_path}/{filename}.chk')
            return False
    # Backup .log and .chk files.
    os.system(f'rm {filename}.gjf')
    os.system(f'mv {filename}.log {scratch_path}/{filename}.log')
    os.system(f'mv {filename}.chk {scratch_path}/{filename}.chk')
    if step==1:
        os.system(f'rm {scratch_path}/{system_name}_ref_stable.chk')
    return ijroots

def stable(X0,state,mult):
    global job_name,system_name,nproc,memory,qm_charge,qm_template
    global atm
    xyz=numpy.matrix.tolist(X0)[0]

    filename=f'{system_name}_state{state}_stable'
    # Run stable=opt task to get stable groud state wavefunction.
    with open(f'{filename}.gjf') as gen:
        gen.write('! Gaussian16 input file generated by XMECP\n')
        gen.write(f'%nprocshared={nproc}\n')
        gen.write(f'%mem={memory}GB\n')
        gen.write(f'%chk={filename}.chk\n')
        gen.write(f'#p stable=opt ')
        with open(qm_template,'r') as read:
            for line in read.readlines():
                l=line.split()
                if len(l)!=0:
                    gen.write(line.strip('\n'))
        gen.write(f'\n\nStable Task\n\n{qm_charge} {mult}\n')
        for i in range(len(atm)):
            gen.write(f'{atm[i]}'.ljust(4))
            for i in range(3):
                gen.write(f'{xyz[j+3*i]:8f}'.rjust(16))
            gen.write('\n')
        gen.write('\n')
        with open(qm_template,'r') as read:
            flag=False
            for line in extrakeys.readlines():
                l=line.split()
                if flag==False and len(l)==0:
                    flag=True
                    continue
                if flag:
                    gen.write(line)
        gen.write('\n\n')

    print('Run single point task to obtain stable wavefunction.')
    with os.popen(f'g16 < {filename}.gjf > {filename}.log') as run:
        null=run.read()
    # Backup files.
    os.system(f'rm {filename}.gjf')
    os.system(f'mv {filename}.log {scratch_path}/{filename}.log')
    os.system(f'mv {filename}.chk {scratch_path}/{filename}.chk')
    return

### >>> Generate Gaussian16 input file for two-states MECP optimization >>> ###
def inp4mecp(X0,step=1):
    global job_name,system_name,nproc,memory,qm_charge,qm_mult,uks,qm_template
    global atm

    # Run stable=opt task at first cycle.
    if step==1:
        refmults=[]
        for i in range(2):
            if mecp_wordlist[0+i]==qm_mult or\
              (mecp_wordlist[0+i]!=qm_mult and mecp_wordlist[2+i]>=2) or\
              (mecp_wordlist[0+i]!=qm_mult and mecp_wordlist[2+i]==1 and mecp_wordlist[4+i]):
                refmults.append(qm_mult)
            else:
                refmults.append(mecp_wordlist[0+i])
        if refmults[0]==refmults[1]:
            stable(X0,1,refmults[0])
            os.system(f'cp {scratch_path}/{system_name}_state1_stable.log {scratch_path}/{system_name}_state2_stable.log')
            os.system(f'cp {scratch_path}/{system_name}_state1_stable.chk {scratch_path}/{system_name}_state2_stable.chk')
        else:
            for i in range(2):
                stable(X0,1+i,refmults[i])
        if qm_mult in refmults:
            if qm_mult==refmults[0]:
                (f'cp {scratch_path}/{system_name}_state1_stable.chk {scratch_path}/{system_name}_ref_stable.chk')
            else:
                (f'cp {scratch_path}/{system_name}_state2_stable.chk {scratch_path}/{system_name}_ref_stable.chk')
        else:
            print('Warning: Spin multiplicities of ground/reference wavefunction for both target states are not QM_Mult!')

    roots=[]
    # Whether to run TD-DFT single point task or not.
    if (qm_mult!=1 and ((if_td1 or if_td2) or\
                        (state1_mult==qm_mult and state1_root!=0) or (state2_mult==qm_mult and state2_root!=0)   or\
                        (state1_mult!=qm_mult and state1_root>=2) or (state2_mult!=qm_mult and state2_root>=2))) or\
       (qm_mult==1 and ((state1_mult!=qm_mult and (if_td1 or state1_root>=2)) or (state2_mult!=qm_mult and (if_td2 or state2_root>=2)))):
        nroots=3+max(state1_root,state2_root)
        # When step>1, read nstates value from previous input.
        if step>1:
            with open(f'{scratch_path}/{system_name}_step{step}_TD.gjf') as read:
                for line in read.readlines():
                    if '#p' in line.lower():
                        l=line.lower().split('=')
                        for i in range(len(l)):
                            if 'nstate' in l[i]:
                                nroots=int(l[1+i].split(')')[0])
                                break
        counter,flag=0,False
        while True:
            ijroots=inp4td(X0,step,nroots,flag)
            flag=True
            if ijroots!=False:
                roots.extend(ijroots)
                break
            else:
                print('Increase CIS space for another 5 states.')
                nroots+=5
                counter+=1
                if counter==5:
                    print('Target state was not found with 20 more states expanding the CIS space.')
                    sys.exit()
    else:
        roots=[state1_root,state2_root]

    for i in range(2):
        # Gaussian16 input files are generated in current folder and filenames are set to ${system_name}_stepN_state1.gjf and ${system_name}_stepN_state2.gjf.
        filename=f'{system_name}_step{step}_state{1+i}'
        with open(filename,'w') as gen:
            gen.write('! Gaussian16 input file generated by XMECP\n')
            gen.write(f'%nprocshared={nproc}\n')
            gen.write(f'%mem={memory}GB\n')
            if step==1:
                gen.write(f'%oldchk={scratch_path}/{system_name}_state{1+i}_stable.chk\n')
            else:
                gen.write(f'%oldchk={scratch_path}/{system_name}_step{step-1}_state{1+i}.chk\n')
            gen.write(f'{filename}.chk')
            gen.write('\n#p nosymm force ')

            with open(qm_template,'r') as read:
                for line in read.readlines():
                    l=line.split()
                    if len(l)!=0:
                        gen.write(line.strip('\n'))
                    else:
                        break

            tddft=False
            if (mecp_wordlist[0+i]==qm_mult and mecp_wordlist[2+i]!=0) or\
               (mecp_wordlist[0+i]!=qm_mult and mecp_wordlist[2+i]==1 and mecp_wordlist[4+i]==True) or\
               (mecp_wordlist[0+i]!=qm_mult and mecp_wordlist[2+i]>=2):
                tddft=True
                gen.write(f'\nTD=(NStates={3+roots[i]},Root={roots[i]}')
                if qm_mult==1 and mecp_wordlist[0+i]==3:
                    gen.write(',Triplets')
                if step>1:
                    gen.write(',Read')
                gen.write(')')

            gen.write(f'\n\n{job_name}\n\n')
            gen.write(f'{qm_charge} ')
            if tddft:
                gen.write(f'{qm_mult}')
            else:
                gen.write(f'{mecp_wordlist[0+i]}')
            for i in range(len(atm)):
                gen.write(f'{atm[i]}'.ljust(4))
                for i in range(3):
                    gen.write(f'{xyz[j+3*i]:8f}'.rjust(16))
                gen.write('\n')
            gen.write('\n')

            with open(qm_template,'r') as read:
                flag=False
                for line in extrakeys.readlines():
                    l=line.split()
                    if flag==False and len(l)==0:
                        flag=True
                        continue
                    if flag:
                        gen.write(line)
            gen.write('\n\n')
    return
### <<< Generate Gaussian16 input file for two-states MECP optimization <<< ###

def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        pass
    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError, ValueError):
        pass
    return False

def energy(energyfile,tddft=False,iroot='auto'):
    scfene=0.
    with open(energyfile,'r') as read:
        for line in readenergy.readlines():
            if len(L)!=0:
                if tddft:
                    if 'Excitation energies and oscillator strengths:' in line:
                        flag=True
                        continue
                    if flag and 'Total Energy,' in line:
                        l=line.split()
                        if iroot==0:
                            return float(l[-1])
                        else:
                            scfene=float(l[-1])-exc[-1]/27.2114 # Corresponding to SCF energy.
                            continue
                    if flag and '<S**2>' in line:
                        l=line.split()
                        for i in range(len(l)):
                            if l[i]=='eV':
                                exc.append(float(l[i-1]))
                        continue
                    if scfene!=0. and len(exc)==iroot:
                        return scfene+exc[iroot-1]/27.2114
                else:
                    if 'SCF Done:' in line:
                        l=line.split()
                        return float(l[4])

def gradient(gradfile):
    gradient=[]
    flag=False
    readgrad=open(gradfile,'r')
    for line in readgrad.readlines():
        L=line.split()
        if len(L)>=2:
            if L[-2]=='Forces' and L[-1]=='(Hartrees/Bohr)':
                flag=True
                continue
            if flag:
                if is_number(L[-3]) and is_number(L[-2]) and is_number(L[-1]):
                    for i in range(3):
                        global bohr
                        gradient.append(-float(L[-(3-i)])/bohr)
                elif L[0]=='Cartesian' and L[1]=='Forces:' and L[2]=='Max':
                    break
    return gradient

def mecpstep(XNew,step):
    print(f'Optimization steps: {step}')
    
    global scratch_path,xyz_backup,ene_backup
    if step==1:
        os.system('mkdir '+scratch_path)
        os.system('rm -f '+xyz_backup+' '+ene_backup)
        with open(ene_backup,'w') as gen:
            gen.write('MECP Optimization\nStep  E_state1          E_state2          deltaE\n')

    global atm
    inp4mecp(XNew,step)

    global mecp_wordlist
    energylist,gradlist=[],[]

    for i in range(2):
        print(f'Run Gaussian16 force calculation for state {1+i}.')
        print(f'State {1+i}: {mecp_wordlist[i]} {mecp_wordlist[2+i]}')

        filename=f'{system_name}_step{step}_state{1+i}'

        tddft=False
        with open(f'{filename}.gjf','r') as read:
            for line in read.readlines():
                l=line.split()
                if len(l)!=0:
                    for i in range(len(l)):
                        if l[i][:2]=='TD':
                            tddft=True
                            break

        with os.popen(f'g16 < {filename}.gjf > {filename}.log') as run:
            null=run.read()
            energylist.append(energy(f'{filename}.log',tddft))
            gradlist.append(gradient(f'{filename}.log'))

    e1,e2=energylist[0],energylist[1]
    g1,g2=gradlist[0],gradlist[1]
    ed=e2-e1

    # Backup energy.
    with open(ene_backup,'a') as backup:
        backup.write(f'{f"{step}".rjust(4)}  {f"{e1:.8f}".rjust(16)}  {f"{e2:.8f}".rjust(16)}  {f"{ed:.8f}".rjust(12)}\n')

    xyz=numpy.matrix.tolist(XNew)[0]
    # Backup geometry.
    global atm
    n=len(atm)
    with open(xyz_backup,'a') as gen:
        gen.write(f'{n}\nMECP Step {step}\n')
        for i in range(n):
            gen.write(f'{atm[i]}'.ljust(2))
            for j in range(3):
                gen.write(f'{xyz[j+3*i]:.8f}'.rjust(16))
            gen.write('\n')

    os.system(f'mv {filename}.* {scratch_path}')
    return e1,g1,e2,g2

