# Combined with ChemShell package.
# Required interfaces:
#     pyscf_fake_orca5.tcl
#     pyscf_interface.py + settings.py

# 2023-03-28
# xujiawei@fjirsm.ac.cn

import os,sys,numpy,geom
from parameters import *

# Region specify format in ChemShell template:
# set qm_atom_numbers { 1-10 20-30 35 }
# set active_atom_numbers { 1-1000 2000-3000 }

### >>> Generate ChemShell input file >>> ###
# We run single PySCF SA-CASSCF calculaion gives two-state gradients for MECP optimization.
def inp4mecp(X0,step=1,tmp=False):
    global system_name,nproc,qm_charge,qm_mult,chemsh_template
    global atm

    # Write coordinates input.
    xyzfile=f'{system_name}.c'
    prmfile=f'{system_name}.prmtop'
    geom.chemshc(atm,X0,prmfile,xyzfile)

    # Write ChemShell input.
    global mecp_wordlist

    chm=f'{system_name}_step{step}.chm'
    if tmp:
        chm=f'{system_name}_step{step}_tmp.chm'

    with open(chm,'w') as gen:
        gen.write(f'# Tcl-ChemShell input file generated by XMECP\n')
        gen.write(f'# Searching for two-state MECP: step {step}\n')

        if tmp:
            gen.write(f'set sysname {system_name}_tmp\n')
        else:
            gen.write(f'set sysname {system_name}\n')

        gen.write(f'set qmcharge {qm_charge}\n')
        gen.write(f'set qmmult {qm_mult}\n')

        import settings
        gen.write(f'\nset orcasimpleinput "{settings.jobtype}"\n')

        addroots=0
        if os.path.exists('pyscf_interface_tmp.py'):
            import pyscf_interface_tmp
            addroots=pyscf_interface_tmp.nroots

        gen.write(f'\
set orcablocks {{\n\
                 %pal nprocs {nproc} end\n\
                 %opt iroot {mecp_wordlist[2]} jroot {mecp_wordlist[3]}\n\
                      imult {mecp_wordlist[0]} jmult {mecp_wordlist[1]}\n\
                      nroots {max(addroots,3+max(mecp_wordlist[2],mecp_wordlist[3]))} end\n\
               }}\n\n')
    os.system(f'cat {chemsh_template} >> {chm}')
    return

def inp4opt(X0,step=1):
    global system_name,nproc,qm_charge,qm_mult,chemsh_template
    global atm

    # Write coordinates input.
    xyzfile=f'{system_name}.c'
    prmfile=f'{system_name}.prmtop'
    geom.chemshc(atm,X0,prmfile,xyzfile)

    # Write ChemShell input.
    global mecp_wordlist
    chm=f'{system_name}_step{step}.chm'
    with open(chm,'w') as gen:
        gen.write(f'# Tcl-ChemShell input file generated by XMECP\n')
        gen.write(f'# Optimization for stationary point: step {step}\n')

        gen.write(f'set sysname {system_name}\n')
        gen.write(f'set qmcharge {qm_charge}\n')
        gen.write(f'set qmmult {qm_mult}\n')

        import settings
        gen.write(f'\nset orcasimpleinput "{settings.jobtype}"\n')

        gen.write(f'\
set orcablocks {{\n\
                 %pal nprocs {nproc} end\n\
                 %opt iroot {mecp_wordlist[0]} imult {mecp_wordlist[2]} end\n\
               }}\n')
    os.system(f'cat {chemsh_template} >> {chm}')
    return
### <<< Generate ChemShell input file <<< ###

def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        pass
    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError, ValueError):
        pass
    return False

### >>> Read energies and gradients >>> ###
def energy(energyfile):
    flag=False
    ene=0.0
    with open(energyfile,'r') as readene:
        for line in readene.readlines():
            L=line.split()
            if flag:
                ene=float(L[0])
            if len(L)==4 and L[2]=='dimensions=1':
                flag=True
    return ene
def gradient(gradfile):
    flag=False
    grad=[]
    readgrad=open(gradfile,'r')
    for line in readgrad.readlines():
        L=line.split()
        if flag:
            grad.append(float(L[0]))
        if len(L)==4 and L[2]=='dimensions=3':
            flag=True
    return grad
### <<< Read energies and gradients <<< ###

def mecpstep(XNew,step):
    print(f'MECP Optimization steps: {step}')

    global scratch_path,xyz_backup,ene_backup
    if step==1:
        os.system(f'rm -rf {xyz_backup} {ene_backup} {scratch_path}; mkdir {scratch_path}')
        with open(ene_backup,'w') as gen:
            gen.write('MECP Optimization\nStep  E_state1          E_state2          deltaE\n')

    xyz=numpy.matrix.tolist(XNew)[0]
    # Recover coordinates of the whole QM/MM system.
    xyz=geom.upd_active_xyz(xyz)
    inp4mecp(xyz,step)
    inp4mecp(xyz,step,True) # Temperary job for second state to get QM/MM energy and gradient.

    global system_name
    os.system(f'cp {system_name}.c {system_name}_tmp.c; cp {system_name}.prmtop {system_name}_tmp.prmtop')

    global mecp_wordlist
    enelist,gradlist=[],[]

    print(f'Run ChemShell eandg calculation.')

    os.system(f'echo "step={step} # Note: for PySCF interface" > xmecp_tmp.py\n')

    chm1,chm2=f'{system_name}_step{step}.chm',f'{system_name}_step{step}_tmp.chm'
    out1,out2=f'{system_name}_step{step}.out',f'{system_name}_step{step}_tmp.out'

    e=f'{system_name}.e'
    g=f'{system_name}.g'

    ef1,ef2=f'{system_name}.e1',f'{system_name}.e2'
    gf1,gf2=f'{system_name}.g1',f'{system_name}.g2'

    # The first state run PySCF SA-CASSCF calculation.
    with os.popen(f'chemsh < {chm1} > {out1}') as run:
        null=run.read()
        os.system(f'mv {e} {ef1}; mv {g} {gf1}')

    # The second state run ChemShell but only get results from the previous job.
    with os.popen(f'chemsh < {chm2} > {out2}') as run:
        null=run.read()
        os.system(f'mv {system_name}_tmp.e {ef2}; mv {system_name}_tmp.g {gf2}')

    e1,e2=energy(ef1),energy(ef2)                                                                                                                                                                                  
    g1,g2=gradient(gf1),gradient(gf2)
    ed=e2-e1

    orca_inp=f'{system_name}_orca.inp'
    orca_out=f'{system_name}_orca.out'

    # Delete useless files.
    os.system(f'rm -f {ef1} {ef2} {gf1} {gf2} FIELD CONFIG CONTROL hybrid* pointcharges.xyz')
    os.system(f'rm -f {orca_inp} {orca_out} {system_name}_orca.engrad')
    os.system(f'rm -f {system_name}_step{step}_guess_NO.fch')
    os.system(f'rm -f {system_name}_tmp.c {system_name}_tmp.prmtop')

    # Backup ChemShell files
    os.system(f'mv {chm1} {scratch_path}/{system_name}_step{step}_state1.chm')
    os.system(f'mv {out1} {scratch_path}/{system_name}_step{step}_state1.out')
    os.system(f'mv {chm2} {scratch_path}/{system_name}_step{step}_state2.chm')
    os.system(f'mv {out2} {scratch_path}/{system_name}_step{step}_state2.out')

    # Backup MOKIT and PySCF files.
    mokit_gjf=f'{system_name}_mokit.gjf'
    mokit_out=f'{system_name}_mokit.out'
    pyscf_inp=f'{system_name}_step{step}.py'
    pyscf_out=f'{system_name}_step{step}.out'
    if step==1 and os.path.exists(mokit_gjf):
        os.system(f'mv {mokit_gjf} {scratch_path}')
    if step==1 and os.path.exists(mokit_out):
        os.system(f'mv {mokit_out} {scratch_path}')
    if os.path.exists(pyscf_inp):
        os.system(f'mv {pyscf_inp} {scratch_path}')
    if os.path.exists(pyscf_out):
        os.system(f'mv {pyscf_out} {scratch_path}')

    with open(ene_backup,'a') as backup:
        backup.write(f'{f"{step}".rjust(4)}  {f"{e1:.8f}".rjust(16)}  {f"{e2:.8f}".rjust(16)}  {f"{ed:.8f}".rjust(12)}\n')

    # Backup geometry.
    global atm
    n=len(atm)
    with open(xyz_backup,'a') as gen:
        gen.write(f'{n}\nMECP Step {step}\n')
        for i in range(n):
            gen.write(f'{atm[i]}'.ljust(2))
            for j in range(3):
                gen.write(f'{xyz[j+3*i]:.8f}'.rjust(16))
            gen.write('\n')

    # Backup QM geometry.
    qm=geom.qm_region()
    n=len(qm)
    qmxyz=geom.qm_xyz(xyz)
    with open(xyz_backup_qm,'a') as gen:
        gen.write(f'{n}\nMECP Step {step}\n')
        for i in range(n):
            gen.write(f'{atm[qm[i]-1]}'.ljust(2))
            for j in range(3):
                gen.write(f'{qmxyz[j+3*i]:.8f}'.rjust(16))
            gen.write('\n')

    # Delete gradient of atoms not in active region.
    g1=geom.active_gradient(g1)
    g2=geom.active_gradient(g2)

    return e1,g1,e2,g2

def optstep(XNew,step):
    print(f'Optimization steps: {step}')

    global scratch_path,xyz_backup,ene_backup
    if step==1:
        os.system(f'rm -rf {xyz_backup} {ene_backup} {scratch_path}; mkdir {scratch_path}')
        with open(ene_backup,'w') as gen:
            gen.write('Optimization\nStep  Energy\n')

    xyz=numpy.matrix.tolist(XNew)[0]
    # Recover coordinates of the whole QM/MM system.
    xyz=geom.upd_active_xyz(xyz)
    inp4opt(xyz,step)

    print('Run ChemShell eandg calculation.')

    chm=f'{system_name}_step{step}.chm'
    out=f'{system_name}_step{step}.out'

    os.system(f'echo "step={step} # Note: for PySCF interface" > xmecp_tmp.py\n')

    with os.popen(f'chemsh < {chm} > {out}') as run:
        null=run.read()

    e=f'{system_name}.e'
    g=f'{system_name}.g'

    e1=energy(e)
    g1=gradient(g)

    orca_inp=f'{system_name}_orca.inp'
    orca_out=f'{system_name}_orca.out'

    # Delete useless files.
    os.system(f'rm -f {system_name}.e {system_name}.g FIELD CONFIG CONTROL hybrid* pointcharges.xyz')
    os.system(f'rm -f {orca_inp} {orca_out} {system_name}_orca.engrad')
    os.system(f'rm -f {system_name}_step{step}_guess_NO.fch')

    # Backup ChemShell files
    os.system(f'mv {chm} {scratch_path}/{system_name}_step{step}.chm')
    os.system(f'mv {out} {scratch_path}/{system_name}_step{step}.out')
    # Backup MOKIT and PySCF files.

    mokit_gjf=f'{system_name}_mokit.gjf'
    mokit_out=f'{system_name}_mokit.out'
    pyscf_inp=f'{system_name}_step{step}.py'
    pyscf_out=f'{system_name}_step{step}.out'
    if step==1 and os.path.exists(mokit_gjf):
        os.system(f'mv {mokit_gjf} {scratch_path}')
    if step==1 and os.path.exists(mokit_out):
        os.system(f'mv {mokit_out} {scratch_path}')
    if os.path.exists(pyscf_inp):
        os.system(f'mv {pyscf_inp} {scratch_path}')
    if os.path.exists(pyscf_out):
        os.system(f'mv {pyscf_out} {scratch_path}')

    with open(ene_backup,'a') as backup:
        backup.write(f'{f"{step}".rjust(4)}  {f"{e1:.8f}".rjust(16)}\n')

    # Backup geometry.
    global atm
    n=len(atm)
    with open(xyz_backup,'a') as gen:
        gen.write(f'{n}\nOptimization Step {step}\n')
        for i in range(n):
            gen.write(f'{atm[i]}'.ljust(2))
            for j in range(3):
                gen.write(f'{xyz[j+3*i]:.8f}'.rjust(16))
            gen.write('\n')

    # Backup QM geometry.
    qm=geom.qm_region()
    n=len(qm)
    qmxyz=geom.qm_xyz(xyz)
    with open(xyz_backup_qm,'a') as gen:
        gen.write(f'{n}\nOptimization Step {step}\n')
        for i in range(n):
            gen.write(f'{atm[qm[i]-1]}'.ljust(2))
            for j in range(3):
                gen.write(f'{qmxyz[j+3*i]:.8f}'.rjust(16))
            gen.write('\n')

    # Delete gradient of atoms not in active region.
    g1=geom.active_gradient(g1)

    return e1,g1
